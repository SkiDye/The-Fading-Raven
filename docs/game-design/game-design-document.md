# The Fading Raven - 게임 디자인 문서

> **장르**: 실시간 전술 로그라이트 (Real-time Tactics Roguelite)
> **레퍼런스**: Bad North
> **테마**: 우주 SF - 정거장 방어

---

## 목차

1. [게임 개요](#1-게임-개요)
2. [핵심 메카닉](#2-핵심-메카닉)
3. [크루 클래스 시스템](#3-크루-클래스-시스템)
4. [스킬 시스템](#4-스킬-시스템)
5. [장비 시스템](#5-장비-시스템)
6. [특성 시스템](#6-특성-시스템)
7. [적 시스템](#7-적-시스템)
8. [정거장 시스템](#8-정거장-시스템)
9. [Raven 드론 시스템](#9-raven-드론-시스템)
10. [캠페인 진행](#10-캠페인-진행)
11. [경제 시스템](#11-경제-시스템)
12. [메타 진행](#12-메타-진행)
13. [절차적 생성 시스템](#13-절차적-생성-시스템)
14. [밸런싱 수치](#14-밸런싱-수치)

---

## 1. 게임 개요

### 1.1 컨셉

**"희미해져 가는 성간 네트워크에서, Raven 드론과 함께 마지막 정거장들을 지켜라"**

플레이어는 우주 폭풍과 해적단의 침략으로부터 정거장 네트워크를 방어하는 함대 사령관이다. 각 정거장을 방어하며 생존자를 구출하고, 크루를 강화하며, 점점 밀려오는 위협에서 탈출해야 한다.

### 1.2 핵심 경험

| 요소 | 설명 |
|------|------|
| **긴장감** | 영구 사망, 제한된 자원, 점점 강해지는 적 |
| **전략적 깊이** | 5클래스 상성, 지형 활용, 시설 선택 |
| **만족감** | 완벽한 배치로 웨이브 무손실 클리어 |
| **리플레이** | 절차적 생성, 다양한 빌드, 메타 해금 |

### 1.3 세계관 키워드

| Bad North | The Fading Raven |
|-----------|------------------|
| 왕국 | 성간 연합 (Stellar Union) |
| 섬 | 우주 정거장 (Station) |
| 집 | 시설 모듈 (Module) |
| 바이킹 | 해적단 + 우주 폭풍 생명체 |
| 왕의 죽음 | 중앙 본부 함락 |
| 탈출 | 최종 점프 게이트 도달 |

### 1.4 "Raven"의 의미

- **Raven**: 플레이어의 기함/모함 이름
- **Fading**: 네트워크가 점점 어둠에 잠식됨
- 기함에서 정찰 드론 "Raven Scout"를 운용

---

## 2. 핵심 메카닉

### 2.1 전투 흐름 (Bad North 동일)

```
[정거장 도착]
      ↓
[크루 배치 (슬로우 모션)]
      ↓
[적 웨이브 침투]
      ↓
[실시간 전투 + 명령]
      ↓
[웨이브 클리어]
      ↓
[시설 방어 결과 → 자원 획득]
      ↓
[다음 정거장 선택]
```

### 2.2 조작 방식

| 조작 | 효과 |
|------|------|
| 크루 선택 | 게임 속도 감소 (슬로우 모션) |
| 타일 클릭 | 이동 명령 |
| 스킬 버튼 | 특수 능력 발동 |
| 시설 클릭 | 회복 명령 |
| Raven 버튼 | 드론 능력 사용 |

### 2.3 승리/패배 조건

**스테이지 승리**
- 모든 웨이브 격퇴
- 시설 1개 이상 생존

**스테이지 패배**
- 모든 시설 파괴 → 자원 0 획득, 진행은 가능
- 모든 크루 전멸 → 게임 오버

**캠페인 승리**
- 최종 점프 게이트 도달 및 방어 성공

**캠페인 패배**
- 모든 팀장 영구 사망

---

## 3. 크루 클래스 시스템

### 3.1 개요

| 클래스 | 역할 | 분대 크기 | 무기 |
|--------|------|----------|------|
| **가디언** | 올라운더, 대원거리 | 8명 | 에너지 실드 + 블래스터 |
| **센티넬** | 병목 방어, 대형 적 카운터 | 8명 | 에너지 랜스 |
| **레인저** | 원거리 딜러 | 8명 | 레이저 라이플 |
| **엔지니어** | 지원, 설치 | 6명 | 권총 + 터렛 |
| **바이오닉** | 고기동, 암살 | 5명 | 에너지 블레이드 |

### 3.2 가디언 (Guardian)

> Bad North의 **보병(Infantry)** 대응

**기본 정보**
| 항목 | 내용 |
|------|------|
| 역할 | 올라운더, 대원거리 특화 |
| 무기 | 에너지 실드 + 블래스터 |
| 분대 크기 | 8명 (7명 크루 + 1명 팀장) |
| 특수 능력 | **Shield Bash** (돌진) |

**장점**
| 장점 | 설명 |
|------|------|
| 에너지 실드 | 원거리 공격 ~90% 데미지 감소 |
| 기동성 | 이동 중 공격 가능 |
| 유연성 | 대부분의 상황에 대응 가능 |

**단점**
| 단점 | 설명 |
|------|------|
| 짧은 리치 | 근접전에서 선제 타격 어려움 |
| 대형 적 취약 | 브루트급에게 밀려남 |
| **교전 중 실드 무효** | 근접 교전 시 실드 방어 불가 |

**운용 전략**
- 적 원거리 유닛 우선 대응
- 센티넬 측면 엄호
- 고지대 확보 후 Shield Bash 활용

---

### 3.3 센티넬 (Sentinel)

> Bad North의 **창병(Pikemen)** 대응

**기본 정보**
| 항목 | 내용 |
|------|------|
| 역할 | 병목 방어, 대브루트 |
| 무기 | 에너지 랜스 (장거리 근접) |
| 분대 크기 | 8명 |
| 특수 능력 | **Lance Charge** (돌격) |

**장점**
| 장점 | 설명 |
|------|------|
| 긴 리치 | 적 접근 전 공격 |
| 병목 최강 | 좁은 통로에서 압도적 방어력 |
| 브루트 카운터 | 대형 적 유일한 확실한 카운터 |

**단점**
| 단점 | 설명 |
|------|------|
| 정지 공격 | 이동 중 공격 불가 |
| **근접 무력화** | 적이 밀착하면 랜스를 들어올림 → 공격 불가 |
| 원거리 취약 | 실드 없음, 정지 상태로 피격 |
| 측면 취약 | 다방향 공격에 약함 |

**핵심 메카닉 - "랜스 들어올림"**
```
적이 grappling range 진입
        ↓
센티넬이 랜스를 위로 들어올림
        ↓
공격 불가 상태 (무력화)
        ↓
해결: Shock Wave로 밀어내거나 다른 유닛 엄호
```

**운용 전략**
- 병목/경사면 배치 필수
- 레인저로부터 보호 필요
- 브루트 출현 시 최우선 배치
- **Shock Wave 장비 권장**

---

### 3.4 레인저 (Ranger)

> Bad North의 **궁수(Archers)** 대응

**기본 정보**
| 항목 | 내용 |
|------|------|
| 역할 | 원거리 딜러, 침투 저지 |
| 무기 | 레이저 라이플 |
| 분대 크기 | 8명 |
| 특수 능력 | **Volley Fire** (일제 사격) |

**장점**
| 장점 | 설명 |
|------|------|
| 원거리 | 안전한 거리에서 공격 |
| 침투 저지 | 적 도착 전 사살 가능 |
| 고지대 보너스 | 명중률/사거리 증가 |

**단점**
| 단점 | 설명 |
|------|------|
| 실드 무효화 | 실드 적에게 완전히 막힘 |
| 이동 타겟 | 움직이는 적 명중률 낮음 |
| 근접 취약 | 접근당하면 무력 |
| **초기 정확도 낮음** | Veteran 전까지 매우 약함 |

**업그레이드 효과 (중요)**
| 등급 | 효과 |
|------|------|
| Standard | 낮은 정확도, 제한적 효용 |
| Veteran | 정확도/사거리/공격속도 증가 |
| Elite | 최대 정확도, 침투 전 전멸 가능 |

**운용 전략**
- 최고 지형 배치 (높을수록 정확도↑)
- **Elite 업그레이드 최우선**
- Volley Fire로 실드 적/이동 타겟 대응
- 그룹 타겟에 더 효과적

---

### 3.5 엔지니어 (Engineer) - 신규

**기본 정보**
| 항목 | 내용 |
|------|------|
| 역할 | 지원, 터렛 설치, 시설 수리 |
| 무기 | 권총 (약함) |
| 분대 크기 | **6명** (5명 + 1명 팀장) |
| 특수 능력 | **Deploy Turret** (터렛 배치) |

**장점**
| 장점 | 설명 |
|------|------|
| 터렛 | 영구 배치 자동 포탑, 추가 화력 |
| 시설 수리 | 파괴된 시설 복구 가능 (시간 소요) |
| 병목 강화 | 터렛 + 센티넬 조합 강력 |

**단점**
| 단점 | 설명 |
|------|------|
| 약한 전투력 | 직접 전투 능력 최하위 |
| 호위 필요 | 단독 운용 불가 |
| 터렛 제한 | 스테이지당 설치 수 제한 |
| **해커 취약** | 적 해커가 터렛 해킹 가능 |

**특수 메카닉 - 터렛 시스템**
| 레벨 | 터렛 수 | 터렛 DPS | 터렛 체력 |
|------|--------|---------|----------|
| Standard | 1개 | 낮음 | 낮음 |
| Veteran | 2개 | 중간 | 중간 |
| Elite | 3개 | 높음 | 높음 |

**특수 메카닉 - 시설 수리**
- 파괴된 시설 타일에서 "수리" 명령
- 수리 시간: 20초 (스테이지 중 위험)
- 수리 완료 시 시설 50% 체력으로 복구
- 자원은 원래의 50%만 획득

**운용 전략**
- 병목 입구에 터렛 배치
- 센티넬/가디언 호위 하에 운용
- 여유 시 파괴 시설 수리
- **적 해커 우선 처치** (터렛 해킹 방지)

---

### 3.6 바이오닉 (Bionic) - 신규

**기본 정보**
| 항목 | 내용 |
|------|------|
| 역할 | 고기동, 암살, 우선순위 타겟 제거 |
| 무기 | 에너지 블레이드 (고데미지) |
| 분대 크기 | **5명** (4명 + 1명 팀장) |
| 특수 능력 | **Blink** (순간이동) |

**장점**
| 장점 | 설명 |
|------|------|
| 고기동 | 기본 이동속도 +50% |
| 암살 보너스 | 비교전 적 공격 시 **2배 데미지** |
| Blink | 짧은 거리 순간이동, 벽 통과 가능 |
| 우선순위 처치 | 스나이퍼, 드론 캐리어 등 신속 제거 |

**단점**
| 단점 | 설명 |
|------|------|
| 적은 인원 | 5명으로 지속전 불리 |
| 낮은 체력 | 개별 유닛 체력 낮음 |
| 정면전 약함 | 다수 적과 정면 교전 시 빠르게 소모 |

**특수 메카닉 - 암살 보너스**
```
조건: 타겟이 다른 유닛과 교전 중이 아님
효과: 첫 공격 데미지 2배
활용: 적 후방의 스나이퍼/지원 유닛 제거
```

**특수 메카닉 - Blink**
| 레벨 | 거리 | 쿨다운 |
|------|------|--------|
| Lv1 | 2타일 | 15초 |
| Lv2 | 4타일 | 12초 |
| Lv3 | 6타일 + 착지 스턴 | 10초 |

**운용 전략**
- 적 원거리/지원 유닛 우선 암살
- 정면전 회피, 측면/후방 기습
- Blink로 위험 시 이탈
- **단독 운용 가능하나 리스크 높음**

---

### 3.7 클래스 상성표

```
              ┌─────────────────────────────────────┐
              │           적 원거리 유닛            │
              └──────────────┬──────────────────────┘
                             │
        ┌────────────────────┼────────────────────┐
        ▼                    ▼                    ▼
    가디언 (실드)        바이오닉 (암살)      레인저 (견제)
        │                    │                    │
        │                    │                    │
        ▼                    ▼                    ▼
  ┌─────────┐          ┌─────────┐          ┌─────────┐
  │ 대형 적 │◀─────────│ 센티넬 │          │ 실드 적 │
  │ (브루트)│          │ (랜스) │          │         │
  └─────────┘          └─────────┘          └────┬────┘
        │                    │                    │
        │                    │                    │
        │              ┌─────┴─────┐              │
        │              │  다수의   │              │
        └─────────────▶│  일반 적  │◀─────────────┘
                       └─────┬─────┘
                             │
                             ▼
                    ┌─────────────────┐
                    │    엔지니어     │
                    │    (터렛)       │
                    └─────────────────┘
```

**요약표**

| 클래스 | 강함 | 약함 | 특수 |
|--------|------|------|------|
| 가디언 | 원거리 적 | 대형 적 | 올라운더 |
| 센티넬 | 대형 적, 병목 | 원거리 적 | 밀착 시 무력화 |
| 레인저 | 비실드 다수 | 실드 적 | 업그레이드 의존 |
| 엔지니어 | 병목 강화 | 직접 전투 | 터렛/수리 |
| 바이오닉 | 후방 타겟 | 다수 정면전 | 암살 보너스 |

---

## 4. 스킬 시스템

### 4.1 개요

각 클래스는 고유 스킬 1개를 보유하며, 3단계 업그레이드 가능.

| 클래스 | 스킬명 | 타입 |
|--------|--------|------|
| 가디언 | Shield Bash | 방향 지정 돌진 |
| 센티넬 | Lance Charge | 방향 지정 돌격 |
| 레인저 | Volley Fire | 위치 지정 일제사격 |
| 엔지니어 | Deploy Turret | 위치 지정 설치 |
| 바이오닉 | Blink | 위치 지정 순간이동 |

### 4.2 Shield Bash (가디언)

**기본 메카닉**
- 지정 방향으로 돌진
- 경로상 적에게 데미지 + 넉백
- 착지 지점에 스턴 효과

**업그레이드**
| 레벨 | 효과 | 비용 |
|------|------|------|
| Lv1 | 3타일 돌진, 넉백 | 7 크레딧 |
| Lv2 | 5타일 돌진, 넉백 강화 | 10 크레딧 |
| Lv3 | 무제한 거리, 착지 스턴 | 14 크레딧 |

**활용**
- 적 무리 분산
- 적을 우주 공간(즉사 지역)으로 밀어넣기
- 위험 시 이탈

### 4.3 Lance Charge (센티넬)

**기본 메카닉**
- 지정 방향으로 직선 돌격
- 경로상 모든 적에게 고데미지
- 돌격 후 즉시 방어 태세

**업그레이드**
| 레벨 | 효과 | 비용 |
|------|------|------|
| Lv1 | 3타일, 브루트 제외 즉사 | 7 크레딧 |
| Lv2 | **무제한 거리** | 10 크레딧 |
| Lv3 | 브루트 포함 즉사 | 14 크레딧 |

**활용**
- 대규모 일반 적 처리
- 점퍼 즉사
- 병력 재정비 시간 확보

**주의사항**
- 직선 평지 필요
- 장애물에 막힘
- **아군 피해 없음**

### 4.4 Volley Fire (레인저)

**기본 메카닉**
- 지정 위치에 전 분대 일제 사격
- 수동 조준으로 이동 타겟 타격
- 실드 적에게도 일부 피해

**업그레이드**
| 레벨 | 효과 | 비용 |
|------|------|------|
| Lv1 | 1타일 타겟 | 7 크레딧 |
| Lv2 | 탄환 수 증가 | 10 크레딧 |
| Lv3 | 최대 탄환, 관통 효과 | 14 크레딧 |

**활용**
- 이동 중인 적 타격
- 실드 적 집단에 피해
- 침투 직전 타이밍

### 4.5 Deploy Turret (엔지니어)

**기본 메카닉**
- 지정 위치에 자동 포탑 설치
- 터렛은 스테이지 종료까지 유지
- 가장 가까운 적 자동 공격

**업그레이드**
| 레벨 | 터렛 수/스테이지 | 터렛 성능 | 비용 |
|------|-----------------|----------|------|
| Lv1 | 1개 | 기본 | 7 크레딧 |
| Lv2 | 2개 | DPS +50% | 10 크레딧 |
| Lv3 | 3개 | DPS +100%, 슬로우 효과 | 14 크레딧 |

**활용**
- 병목 입구 배치
- 센티넬과 조합
- 다방향 방어 시 화력 분산

**주의사항**
- 적 해커에게 해킹당할 수 있음
- 해킹된 터렛은 아군 공격

### 4.6 Blink (바이오닉)

**기본 메카닉**
- 지정 위치로 순간이동
- 벽/장애물 통과 가능
- 이동 후 짧은 무적 시간

**업그레이드**
| 레벨 | 거리 | 추가 효과 | 비용 |
|------|------|----------|------|
| Lv1 | 2타일 | - | 7 크레딧 |
| Lv2 | 4타일 | 쿨다운 -20% | 10 크레딧 |
| Lv3 | 6타일 | 착지 시 주변 적 스턴 | 14 크레딧 |

**활용**
- 적 후방 침투
- 위험 시 탈출
- 고립된 우선순위 타겟 암살

---

## 5. 장비 시스템

### 5.1 개요

- 총 **10종** 장비
- 팀장에게 장착
- **장착 후 해제 불가**
- 업그레이드로 효과 강화

### 5.2 장비 목록

| 장비 | 타입 | 효과 | 추천 클래스 |
|------|------|------|------------|
| **Command Module** | 패시브 | 분대 크기 증가 | 레인저 |
| **Shock Wave** | 액티브 (쿨다운) | AOE 넉백 | 센티넬 |
| **Frag Grenade** | 액티브 (횟수) | 투척 폭발물 | 레인저 |
| **Proximity Mine** | 액티브 (횟수) | 설치형 지뢰 | 엔지니어 |
| **Rally Horn** | 액티브 (횟수) | 즉시 병력 보충 | 가디언 |
| **Revive Kit** | 액티브 (1회) | 전멸 팀 부활 | 핵심 팀장 |
| **Stim Pack** | 패시브 | 턴당 추가 행동 | 바이오닉 |
| **Salvage Core** | 패시브 | 추가 크레딧 획득 | 아무나 |
| **Shield Generator** | 액티브 (쿨다운) | 일시적 팀 실드 | 센티넬 |
| **Hacking Device** | 액티브 (횟수) | 적 터렛/드론 해킹 | 엔지니어 |

### 5.3 상세 - Command Module

> Bad North의 Ring of Command 대응

**효과**
- 분대 크기 증가
- 레인저: 탄환 수 증가

**업그레이드**
| 레벨 | 분대 크기 | 회복 시간 | 비용 |
|------|----------|----------|------|
| Lv1 | 8명 → **11명** | 16초 → 22초 | 기본 |
| Lv2 | 11명 → **14명** | 22초 → 28초 | 16 크레딧 |

### 5.4 상세 - Shock Wave

> Bad North의 Warhammer 대응

**효과**
- 전방 점프 후 AOE 데미지 + 넉백
- 쿨다운: 40초
- 아군 피해 있음 (약함)

**추천**: 센티넬 (랜스 들어올림 탈출용)

### 5.5 상세 - Frag Grenade

> Bad North의 Bomb 대응

**효과**
- 투척형 폭발물
- 사거리: 2타일
- **아군 피해 있음**

**업그레이드**
| 레벨 | 사용 횟수 | 비용 |
|------|----------|------|
| Lv1 | 1개/스테이지 | 기본 |
| Lv2 | 2개/스테이지 | 8 크레딧 |
| Lv3 | 3개 + AOE 증가 | 14 크레딧 |

### 5.6 상세 - Proximity Mine

> Bad North의 Mines 대응

**효과**
- 설치형 지뢰
- 적 접근 시 폭발

**업그레이드**
| 레벨 | 사용 횟수 | 비용 |
|------|----------|------|
| Lv1 | 1개/스테이지 | 기본 |
| Lv2 | 2개/스테이지 | 8 크레딧 |
| Lv3 | 3개 + 데미지 증가 | 14 크레딧 |

**주의**: 침투정 착륙 충격으로 오작동 가능

### 5.7 상세 - Rally Horn

> Bad North의 War Horn 대응

**효과**
- 즉시 병력 보충
- 시설 점거 없이 현장 보충

**추천**: 가디언 (전투 중 손실 즉시 보충)

### 5.8 상세 - Revive Kit

> Bad North의 Holy Grail 대응

**효과**
- 전멸한 팀 1회 부활
- **캠페인당 1회만 사용**

**제한**: 철수 중 사망은 부활 불가

### 5.9 상세 - Stim Pack

> Bad North의 Jabena 대응

**효과**
- 턴당 추가 행동/공격

**추천**: 바이오닉 (DPS 극대화)

### 5.10 상세 - Salvage Core

> Bad North의 Philosopher's Stone 대응

**효과**
- 스테이지 클리어 시 추가 크레딧
- **해당 팀 배치 필수**

**업그레이드**
| 레벨 | 추가 크레딧 | 비용 |
|------|------------|------|
| Lv1 | +1/스테이지 | 기본 |
| Lv2 | +2/스테이지 | 5 크레딧 |
| Lv3 | +3/스테이지 | 9 크레딧 |

### 5.11 상세 - Shield Generator (신규)

**효과**
- 발동 시 팀 전체에 일시적 에너지 실드
- 지속 시간: 5초
- 쿨다운: 60초

**추천**: 센티넬 (원거리 공격 방어)

### 5.12 상세 - Hacking Device (신규)

**효과**
- 적 터렛 또는 드론 해킹
- 해킹된 유닛은 아군으로 전환

**업그레이드**
| 레벨 | 사용 횟수 | 해킹 대상 | 비용 |
|------|----------|----------|------|
| Lv1 | 1회 | 터렛만 | 기본 |
| Lv2 | 2회 | 터렛/소형 드론 | 10 크레딧 |
| Lv3 | 3회 | 터렛/모든 드론 | 16 크레딧 |

---

## 6. 특성 시스템

### 6.1 개요

- 총 **15종** 특성
- 팀장 영입 시 무작위 부여
- 클래스/장비와 시너지 고려

### 6.2 전투 특성 (6종)

| 특성 | 효과 | 추천 |
|------|------|------|
| **Sharp Edge** | 데미지 +20%, 넉백 -30% | 센티넬 |
| **Heavy Impact** | 넉백 +50%, 스턴 +50% | 레인저 |
| **Titan Frame** | 팀장 체력 3배, 크기 증가 | 가디언 |
| **Reinforced Armor** | 받는 데미지 -25% | 범용 |
| **Steady Stance** | 넉백/스턴 저항 | 가디언 |
| **Fearless** | 절대 후퇴 안 함 | 위험 |

### 6.3 유틸리티 특성 (5종)

| 특성 | 효과 | 추천 |
|------|------|------|
| **Energetic** | 스킬 쿨다운 -33% | 바이오닉 |
| **Swift Movement** | 이동속도 +33% | 범용 |
| **Popular** | 분대 크기 +1 | 레인저 |
| **Quick Recovery** | 회복 시간 -33% | 범용 |
| **Tech Savvy** | 터렛 성능 +50% | 엔지니어 |

### 6.4 경제 특성 (4종)

| 특성 | 효과 |
|------|------|
| **Skillful** | 스킬 업그레이드 비용 -50% |
| **Collector** | 장비 업그레이드 비용 -50% |
| **Heavy Load** | 소모품 사용 횟수 +1 |
| **Salvager** | 적 처치 시 소량 크레딧 |

### 6.5 특성-클래스 최적 조합

| 클래스 | 최적 특성 | 이유 |
|--------|----------|------|
| 가디언 | Steady Stance | 침투정 넉백 면역 |
| 가디언 | Titan Frame | 탱킹 + 브루트 대응 |
| 센티넬 | Sharp Edge | 빠른 처치 |
| 레인저 | Heavy Impact | 실드 적 밀어내기 |
| 레인저 | Popular | 탄환 수 증가 |
| 엔지니어 | Tech Savvy | 터렛 강화 |
| 바이오닉 | Energetic | Blink 쿨다운 감소 |
| 바이오닉 | Swift Movement | 기동성 극대화 |

---

## 7. 적 시스템

### 7.1 적 분류

```
기본 적 (Tier 1)
├── 러셔 (Rusher)
├── 건너 (Gunner)
└── 실드 트루퍼 (Shield Trooper)

중급 적 (Tier 2)
├── 점퍼 (Jumper)
├── 헤비 트루퍼 (Heavy Trooper)
├── 해커 (Hacker)
└── 폭풍 생명체 (Storm Creature)

고급 적 (Tier 3)
├── 브루트 (Brute)
├── 스나이퍼 (Sniper)
├── 드론 캐리어 (Drone Carrier)
└── 실드 제너레이터 (Shield Generator)

보스급 (Boss)
├── 해적 대장 (Pirate Captain)
└── 폭풍 핵 (Storm Core)
```

### 7.2 기본 적 (Tier 1)

#### 러셔 (Rusher)
> Bad North의 바이킹(검) 대응

| 항목 | 내용 |
|------|------|
| 무장 | 근접 무기 |
| 체력 | 1히트 사망 |
| 특징 | 기본 근접 적 |
| 위협도 | ★☆☆☆☆ |
| 카운터 | 모든 클래스 |

#### 건너 (Gunner)
> Bad North의 바이킹 궁수 대응

| 항목 | 내용 |
|------|------|
| 무장 | 원거리 무기 |
| 체력 | 1히트 사망 |
| 특징 | 센티넬/레인저 위협 |
| 위협도 | ★★☆☆☆ |
| 카운터 | **가디언 (실드)** |

#### 실드 트루퍼 (Shield Trooper)
> Bad North의 바이킹 방패병 대응

| 항목 | 내용 |
|------|------|
| 무장 | 실드 + 근접 무기 |
| 체력 | 2히트 |
| 특징 | 정면 원거리 공격 방어 |
| 위협도 | ★★☆☆☆ |
| 카운터 | 측면 공격, Volley Fire, 센티넬 |

### 7.3 중급 적 (Tier 2)

#### 점퍼 (Jumper)
> Bad North의 Dual Wielders 대응

| 항목 | 내용 |
|------|------|
| 무장 | 이중 블레이드 |
| 체력 | 2히트 |
| 특징 | **점프팩으로 센티넬 방어선 우회** |
| 위협도 | ★★★★☆ |
| 카운터 | **레인저 (침투 전)**, 바이오닉 |

**특수 메카닉**
- 점프 공격 쿨다운: ~3초
- 병력 처치 우선 (시설보다)
- 센티넬 방어선 무시

#### 헤비 트루퍼 (Heavy Trooper)
> Bad North의 Huscarls 대응

| 항목 | 내용 |
|------|------|
| 무장 | 실드 + 투척 수류탄 |
| 체력 | 3히트 |
| 특징 | **만능형, 약점 없음** |
| 위협도 | ★★★★☆ |
| 카운터 | 협공, 스킬 |

**특수 메카닉**
- 투척 수류탄으로 센티넬 대열 붕괴
- 실드로 원거리 방어
- 근접전 우수

#### 해커 (Hacker) - 신규

| 항목 | 내용 |
|------|------|
| 무장 | 해킹 장치 |
| 체력 | 1히트 |
| 특징 | **터렛/시스템 해킹** |
| 위협도 | ★★★☆☆ |
| 카운터 | **우선 처치 필수** |

**특수 메카닉**
- 아군 터렛 접근 시 해킹 시도 (5초)
- 해킹 성공 시 터렛이 아군 공격
- 직접 전투력 없음

#### 폭풍 생명체 (Storm Creature) - 신규

| 항목 | 내용 |
|------|------|
| 무장 | 에너지 방출 |
| 체력 | 2히트 |
| 특징 | **폭풍 스테이지 전용**, 자폭 |
| 위협도 | ★★★☆☆ |
| 카운터 | 원거리 처치 |

**특수 메카닉**
- 근접 시 자폭 (주변 피해)
- 레인저로 원거리 처치 권장

### 7.4 고급 적 (Tier 3)

#### 브루트 (Brute)
> Bad North 동일

| 항목 | 내용 |
|------|------|
| 무장 | 대형 근접 무기 |
| 체력 | **높음** (5~8히트) |
| 특징 | 강력한 넉백, 높은 데미지 |
| 위협도 | ★★★★★ |
| 카운터 | **센티넬 필수** |

**특수 메카닉**
- 1히트에 일반 유닛 즉사
- 넉백으로 우주 공간 추락 유발
- 2~4마리 그룹 출현

#### 스나이퍼 (Sniper) - 신규

| 항목 | 내용 |
|------|------|
| 무장 | 초장거리 라이플 |
| 체력 | 1히트 |
| 특징 | **맵 어디서든 공격**, 고데미지 |
| 위협도 | ★★★★★ |
| 카운터 | **바이오닉 암살** |

**특수 메카닉**
- 조준 시간 3초 (레이저 표시)
- 조준 완료 시 1히트 즉사
- 이동 중에는 조준 불가

#### 드론 캐리어 (Drone Carrier) - 신규

| 항목 | 내용 |
|------|------|
| 무장 | 소형 공격 드론 |
| 체력 | 3히트 |
| 특징 | **드론 지속 소환** |
| 위협도 | ★★★★★ |
| 카운터 | **본체 우선 처치** |

**특수 메카닉**
- 10초마다 드론 2기 소환
- 드론: 1히트 사망, 원거리 공격
- 본체 사망 시 드론 전부 비활성화

#### 실드 제너레이터 (Shield Generator) - 신규

| 항목 | 내용 |
|------|------|
| 무장 | 없음 |
| 체력 | 2히트 |
| 특징 | **주변 적에게 실드 부여** |
| 위협도 | ★★★★☆ |
| 카운터 | **최우선 처치** |

**특수 메카닉**
- 반경 2타일 적에게 실드 부여
- 실드 적: 원거리 데미지 면역
- 본체 사망 시 실드 해제

### 7.5 보스급

#### 해적 대장 (Pirate Captain)

| 항목 | 내용 |
|------|------|
| 출현 | 특정 웨이브 (5웨이브마다) |
| 체력 | **매우 높음** (15히트) |
| 특징 | 강화 버프, 특수 공격 |
| 보상 | 추가 크레딧, 희귀 장비 |

**특수 패턴**
1. 주변 적 버프 (데미지 +50%)
2. 돌진 공격 (넉백)
3. 증원 호출 (러셔 5명)

#### 폭풍 핵 (Storm Core)

| 항목 | 내용 |
|------|------|
| 출현 | 폭풍 스테이지 |
| 체력 | **파괴 불가** |
| 특징 | 환경 위험, 시간 제한 |
| 해결 | 모든 웨이브 클리어 시 자동 퇴각 |

**특수 메카닉**
- 주기적으로 에너지 파동 (전체 데미지)
- 폭풍 생명체 지속 소환
- 시설에 지속 데미지

### 7.6 적 상성 요약표

| 적 | 가디언 | 센티넬 | 레인저 | 엔지니어 | 바이오닉 |
|----|--------|--------|--------|----------|----------|
| 러셔 | ○ | ◎ | ○ | △ | ○ |
| 건너 | **◎** | × | △ | × | ○ |
| 실드 트루퍼 | ○ | ◎ | × | △ | ○ |
| 점퍼 | △ | × | **◎** | × | ◎ |
| 헤비 트루퍼 | △ | △ | △ | × | △ |
| 해커 | ○ | ○ | ○ | **최우선** | ◎ |
| 폭풍 생명체 | × | × | **◎** | △ | △ |
| 브루트 | × | **◎** | △ | × | × |
| 스나이퍼 | △ | × | △ | × | **◎** |
| 드론 캐리어 | △ | △ | ○ | △ | **◎** |
| 실드 제너레이터 | **최우선** | **최우선** | × | △ | **◎** |

◎ 강력 카운터 | ○ 효과적 | △ 보통 | × 비효과적

---

## 8. 정거장 시스템

### 8.1 정거장 구조

- 타일 기반 맵 (Bad North 섬과 동일)
- 다양한 시설 모듈 배치
- 우주 공간 = 즉사 지역 (물 대응)
- 에어락/복도 = 병목 지점

### 8.2 시설 모듈 (5종)

> Bad North의 "집"을 다양화

| 시설 | 크레딧 | 특수 효과 |
|------|--------|----------|
| **거주 모듈** | 1~3 | 기본 (크기에 따라) |
| **의료 모듈** | 2 | 회복 시간 -50% |
| **무기고** | 2 | 해당 스테이지 데미지 +20% |
| **통신탑** | 1 | Raven 드론 능력 +1회 |
| **발전소** | 3 | 터렛 성능 +50% |

### 8.3 시설 파괴 메카닉

**파괴 과정**
1. 적이 시설 도달
2. 폭발물 설치 (5초)
3. 폭발 → 시설 파괴

**엔지니어 수리**
- 파괴된 시설 타일에서 수리 가능
- 수리 시간: 20초
- 복구 시 원래 크레딧의 50%

### 8.4 전략적 선택

시설마다 효과가 다르므로, **어떤 시설을 지킬지** 선택해야 함:

```
예시 스테이지:
- 거주 모듈 (3 크레딧) - 입구 근처, 방어 어려움
- 의료 모듈 (2 크레딧) - 중앙, 회복 시간 단축
- 무기고 (2 크레딧) - 안쪽, 데미지 버프

전략 A: 모두 방어 시도
전략 B: 거주 모듈 포기, 나머지 집중 방어
전략 C: 무기고 최우선, 버프로 효율적 방어
```

---

## 9. Raven 드론 시스템

### 9.1 개요

> The Fading Raven의 핵심 차별점

- 플레이어의 기함 "Raven"에서 드론 운용
- 스테이지당 제한된 횟수 사용
- 전략적 타이밍이 중요

### 9.2 드론 능력 (4종)

| 능력 | 효과 | 기본 횟수 |
|------|------|----------|
| **정찰 (Scout)** | 다음 웨이브 구성 미리 보기 | 매 웨이브 |
| **조명탄 (Flare)** | 폭풍 스테이지 시야 확보 (10초) | 2회 |
| **긴급 보급 (Resupply)** | 1팀 즉시 회복 | 1회 |
| **궤도 폭격 (Orbital Strike)** | 지정 타일 고데미지 | 1회 |

### 9.3 상세 - 정찰 (Scout)

**효과**
- 다음 웨이브의 적 구성 표시
- 침투 방향/타이밍 힌트

**활용**
- 클래스 배치 최적화
- 위험 웨이브 사전 대비

### 9.4 상세 - 조명탄 (Flare)

**효과**
- 폭풍 스테이지에서 시야 확보
- 10초간 전체 맵 가시

**활용**
- 폭풍 생명체 위치 파악
- 스나이퍼 조기 발견

### 9.5 상세 - 긴급 보급 (Resupply)

**효과**
- 1팀 즉시 풀 회복
- 시설 점거 불필요

**활용**
- 위기 상황 구출
- 회복 시간 없이 재투입

### 9.6 상세 - 궤도 폭격 (Orbital Strike)

**효과**
- 지정 타일 + 인접 타일 고데미지
- 브루트급도 큰 피해
- **아군 피해 있음**

**활용**
- 보스급 적 딜링
- 밀집된 적 웨이브 처리
- 최후의 수단

### 9.7 통신탑 보너스

통신탑 시설 방어 시:
- 조명탄 +1회
- 긴급 보급 +1회
- 궤도 폭격 +1회 (통신탑 2개 이상)

---

## 10. 캠페인 진행

### 10.1 맵 구조

```
[시작점: Raven 함]
       │
       ▼
   ┌───┴───┐
   │       │
 정거장A  정거장B
   │       │
   └───┬───┘
       │
   ┌───┴───┐
   │       │
 정거장C  정거장D (팀장)
   │       │
   └───┬───┘
       │
      ...
       │
       ▼
 [최종: 점프 게이트]
```

### 10.2 맵 아이콘

| 아이콘 | 의미 |
|--------|------|
| 일반 | 기본 정거장 |
| 🚩 깃발 | 새 팀장 영입 가능 |
| ❓ 물음표 | 장비 획득 가능 |
| ⚡ 번개 | 폭풍 스테이지 (위험 + 보상↑) |
| 💀 해골 | 해적 대장 출현 |
| 🚪 게이트 | 최종 목표 |

### 10.3 폭풍 전선

- 매 턴 폭풍 전선이 전진
- 점선 표시된 정거장: 다음 턴에 소멸
- **뒤로 돌아갈 수 없음**

### 10.4 턴 시스템

**기본 규칙**
- 턴당 각 팀장 1회 전투
- 팀장 수 = 턴당 가능 전투 수
- 휴식 = 턴 종료 + 폭풍 전선 전진

### 10.5 팀장 영입

- 깃발 정거장 = 새 팀장 대기
- 해당 정거장 방어 성공 시 영입
- **홈 정거장에서는 철수 불가**
- 같은 특성 팀장 중복 등장 안 함

### 10.6 철수 (Flee)

**철수 조건**
- 빈 침투정 필요
- 침투정 크기 ≥ 분대 크기
- 홈 정거장 불가
- Fearless 특성 불가

**철수 중 메카닉**
- 레인저는 철수 중에도 사격 가능
- 철수 명령 취소 불가

---

## 11. 경제 시스템

### 11.1 자원: 크레딧

- 시설 방어 성공 시 획득
- 팀장 업그레이드, 스킬/장비 강화에 사용

### 11.2 크레딧 획득

**시설별 크레딧**
| 시설 | 크레딧 |
|------|--------|
| 소형 거주 모듈 | 1 |
| 중형 거주 모듈 | 2 |
| 대형 거주 모듈 | 3 |
| 의료/무기고/통신탑 | 2 |
| 발전소 | 3 |

**보너스 크레딧**
- Salvage Core: +1~3/스테이지
- 해적 대장 처치: +5
- 완벽 방어 (모든 시설): +2

### 11.3 지출 항목

| 항목 | 비용 |
|------|------|
| 클래스 업그레이드 (Rookie→Standard) | 6 크레딧 |
| Veteran | 12 크레딧 |
| Elite | 20 크레딧 |
| 스킬 Lv1 | 7 크레딧 |
| 스킬 Lv2 | 10 크레딧 |
| 스킬 Lv3 | 14 크레딧 |
| 장비 업그레이드 | 5~16 크레딧 |

### 11.4 경제 전략

**원칙**
1. 분산 투자 금지
2. 핵심 팀 집중 강화
3. 전투력 > 경제 장비

**우선순위**
```
1. 핵심 팀 Veteran
2. 핵심 팀 Elite
3. 스킬 Lv1 (필수 클래스)
4. 장비 Lv1
5. 추가 팀 업그레이드
```

---

## 12. 메타 진행

### 12.1 영구 해금 시스템

런을 거듭하며 영구적으로 해금되는 요소:

| 해금 대상 | 해금 조건 |
|-----------|----------|
| 새 클래스 | 특정 조건 달성 |
| 시작 특성 | 해당 특성 팀장으로 클리어 |
| 시작 장비 | 해당 장비로 특정 정거장 클리어 |
| 난이도 | 이전 난이도 클리어 |

### 12.2 클래스 해금

| 클래스 | 해금 조건 |
|--------|----------|
| 가디언 | 기본 해금 |
| 센티넬 | 기본 해금 |
| 레인저 | 기본 해금 |
| 엔지니어 | 첫 클리어 |
| 바이오닉 | Hard 난이도 클리어 |

### 12.3 도전 과제

| 과제 | 조건 | 보상 |
|------|------|------|
| 첫 탈출 | 캠페인 클리어 | 엔지니어 해금 |
| 완벽주의자 | 모든 시설 방어로 클리어 | 특수 장비 |
| 암살자 | 바이오닉으로 보스 10회 처치 | 특수 특성 |
| 터렛 마스터 | 터렛으로 100명 처치 | 터렛 스킨 |

### 12.4 난이도

| 난이도 | 해금 조건 | 특징 |
|--------|----------|------|
| Normal | 기본 | 표준 |
| Hard | Normal 클리어 | 적 수 +50%, 웨이브 +1 |
| Very Hard | Hard 클리어 | 적 수 +100%, 보스 강화 |
| Nightmare | Very Hard 클리어 | 영구 사망 제한 없음 |

---

## 13. 절차적 생성 시스템

### 13.1 개요

> Bad North와 동일하게 **매 플레이스루마다 새로운 맵**이 생성됨

**절차적 생성 대상**
| 대상 | 설명 |
|------|------|
| 섹터 맵 | 정거장 배치, 경로, 이벤트 분포 |
| 정거장 레이아웃 | 타일 배치, 시설 위치, 진입 지점 |
| 적 웨이브 구성 | 적 종류, 수량, 침투 방향/타이밍 |
| 아이템/특성 풀 | 획득 가능한 장비/팀장 특성 |

**시드 시스템**
- 각 런마다 고유 시드(Seed) 생성
- 시드 공유로 동일한 맵 재현 가능
- 도전 모드/일일 챌린지에 활용

---

### 13.2 섹터 맵 생성

#### 13.2.1 기본 구조

```
[시작점: Raven 함] ─ 깊이 0
        │
   ┌────┼────┐
   │    │    │
  ○    ○    ○  ─ 깊이 1 (2~3개)
   │    │    │
   └────┼────┘
        │
      ...
        │
   ┌────┼────┐
   │    │    │
  ○    ○    ○  ─ 깊이 N (최종 단계)
   │    │    │
   └────┴────┘
        │
 [점프 게이트]
```

#### 13.2.2 생성 파라미터

| 파라미터 | Normal | Hard | Very Hard | Nightmare |
|----------|--------|------|-----------|-----------|
| 총 깊이 (턴 수) | 12~15 | 15~18 | 18~22 | 22~25 |
| 깊이당 노드 수 | 2~3 | 2~4 | 3~4 | 3~5 |
| 분기 확률 | 60% | 70% | 80% | 90% |
| 합류 확률 | 40% | 50% | 60% | 70% |

#### 13.2.3 노드 배치 알고리즘

```
1. 시작점 생성 (깊이 0)
2. FOR 깊이 1 to N:
   a. 노드 수 = random(min_nodes, max_nodes)
   b. 각 노드 X좌표 = 균등 분포 + 약간의 랜덤 오프셋
   c. 이전 깊이 노드들과 연결 (최소 1개, 최대 2개)
   d. 고립 노드 방지: 연결 없는 노드 → 가장 가까운 노드에 연결
3. 최종 깊이 노드들 → 점프 게이트에 연결
4. 폭풍 전선 초기 위치 설정 (깊이 0 바로 뒤)
```

#### 13.2.4 이벤트 노드 배치

| 이벤트 | 출현 규칙 | 최소 간격 |
|--------|----------|----------|
| 🚩 팀장 영입 | 깊이 2~3에 첫 출현, 이후 3~4 깊이마다 | 3 깊이 |
| ❓ 장비 획득 | 깊이 1부터 출현, 2~3 깊이마다 | 2 깊이 |
| ⚡ 폭풍 스테이지 | 깊이 4부터 출현, 15~25% 확률 | 2 깊이 |
| 💀 해적 대장 | 깊이 5부터 출현, 5 깊이마다 보장 | 4 깊이 |
| 휴식 노드 | 깊이 6, 12, 18에 선택적 | 6 깊이 |

**배치 규칙**
```
1. 필수 이벤트 먼저 배치 (팀장 2~3개, 게이트 1개)
2. 보스 노드 배치 (5, 10, 15... 깊이)
3. 장비 노드 무작위 배치 (확률 기반)
4. 폭풍 노드 무작위 배치 (최소 간격 준수)
5. 나머지는 일반 노드
6. 같은 깊이에 동일 이벤트 2개 이상 금지
```

#### 13.2.5 난이도 곡선

```
난이도 점수 = 기본값 + (깊이 × 스케일링)

Normal:    난이도 = 1.0 + (깊이 × 0.15)
Hard:      난이도 = 1.5 + (깊이 × 0.20)
Very Hard: 난이도 = 2.0 + (깊이 × 0.25)
Nightmare: 난이도 = 2.5 + (깊이 × 0.30)
```

**난이도 점수 → 스테이지 구성**
| 난이도 점수 | 웨이브 수 | 적 수 배율 | 고급 적 비율 |
|-------------|----------|-----------|-------------|
| 1.0~2.0 | 2~3 | ×1.0 | 0% |
| 2.0~3.0 | 3~4 | ×1.2 | 10% |
| 3.0~4.0 | 4~5 | ×1.5 | 25% |
| 4.0~5.0 | 5~6 | ×2.0 | 40% |
| 5.0+ | 6+ | ×2.5 | 50%+ |

---

### 13.3 정거장 레이아웃 생성

#### 13.3.1 기본 구조

```
┌─────────────────────────────────────┐
│            우주 공간 (즉사)          │
│  ┌─────────────────────────────┐    │
│  │         정거장 외곽          │    │
│  │  ┌──────┬──────┬──────┐    │    │
│  │  │시설A │ 복도 │시설B │    │    │
│  │  ├──────┼──────┼──────┤    │◀──침투점
│  │  │ 복도 │ 중앙 │ 복도 │    │    │
│  │  ├──────┼──────┼──────┤    │    │
│  │  │시설C │ 복도 │시설D │    │◀──침투점
│  │  └──────┴──────┴──────┘    │    │
│  └─────────────────────────────┘    │
│                                      │
└─────────────────────────────────────┘
```

#### 13.3.2 맵 크기 파라미터

| 난이도 점수 | 맵 크기 | 타일 수 | 시설 수 |
|-------------|--------|--------|--------|
| 1.0~2.0 | Small | 5×5 (25) | 2~3 |
| 2.0~3.0 | Medium | 7×7 (49) | 3~4 |
| 3.0~4.5 | Large | 9×9 (81) | 4~5 |
| 4.5+ | X-Large | 11×11 (121) | 5~6 |

#### 13.3.3 타일 타입

| 타일 타입 | 설명 | 통과 |
|-----------|------|------|
| 바닥 (Floor) | 기본 이동 가능 타일 | O |
| 시설 (Facility) | 시설 모듈 위치, 방어 대상 | O |
| 벽 (Wall) | 이동 불가, 시야 차단 | X |
| 우주 (Void) | 즉사 지역 | X (추락) |
| 에어락 (Airlock) | 병목 지점, 침투 가능 | O |
| 고지대 (Elevated) | 원거리 보너스 | O |
| 저지대 (Lowered) | 방어 불리 | O |

#### 13.3.4 레이아웃 생성 알고리즘

```
Phase 1: 기본 형태 생성
1. 맵 크기에 맞는 외곽 설정
2. 중앙에 메인 홀 배치 (2×2 ~ 3×3)
3. 외곽에 시설 배치 구역 마킹

Phase 2: 시설 배치
1. 난이도에 따른 시설 수 결정
2. 시설 타입 풀에서 랜덤 선택
   - 거주 모듈: 40% (크기 랜덤)
   - 의료 모듈: 15%
   - 무기고: 15%
   - 통신탑: 15%
   - 발전소: 15%
3. 마킹된 구역에 배치 (최소 2타일 간격)

Phase 3: 경로 생성
1. 모든 시설 간 복도 연결 (MST 알고리즘)
2. 추가 복도로 순환 경로 생성 (20~40% 확률)
3. 병목 지점 자연 형성 확인

Phase 4: 침투점 배치
1. 외곽 타일 중 에어락 후보 선정
2. 시설과의 거리 기반 난이도 조절
   - 쉬움: 침투점 → 시설 거리 5+ 타일
   - 어려움: 침투점 → 시설 거리 2~3 타일
3. 최소 2개, 최대 4개 배치

Phase 5: 고도 설정
1. 중앙부 → 고지대 (25% 확률)
2. 외곽부 → 저지대 (15% 확률)
3. 시설 주변 → 평지 유지
```

#### 13.3.5 레이아웃 템플릿

**기본 템플릿** (50% 사용)
```
  [침투]     [침투]
     ↓         ↓
┌────┬───┬───┬────┐
│시설│   │   │시설│
├────┼───┼───┼────┤
│    │중앙│중앙│    │
├────┼───┼───┼────┤
│시설│   │   │시설│
└────┴───┴───┴────┘
     ↑         ↑
  [침투]     [침투]
```

**병목 템플릿** (25% 사용)
```
       [침투]
          ↓
    ┌────┬────┐
    │시설│시설│
    ├────┼────┤
    │복도│복도│  ← 좁은 복도
    ├────┼────┤
    │중앙│중앙│
    ├────┼────┤
    │시설│시설│
    └────┴────┘
```

**분산 템플릿** (25% 사용)
```
[침투]           [침투]
   ↓               ↓
┌────┐         ┌────┐
│시설│         │시설│
└────┘         └────┘
       ┌────┐
       │중앙│
       └────┘
┌────┐         ┌────┐
│시설│         │시설│
└────┘         └────┘
   ↑               ↑
[침투]           [침투]
```

---

### 13.4 적 웨이브 생성

#### 13.4.1 웨이브 구성 파라미터

```
웨이브 예산 = 기본값 × 난이도 배율 × (1 + 웨이브번호 × 0.2)

Normal 기본값: 10
Hard 기본값: 15
Very Hard 기본값: 20
Nightmare 기본값: 25
```

#### 13.4.2 적 비용 테이블

| 적 타입 | 비용 | 출현 조건 |
|---------|------|----------|
| 러셔 | 1 | 항상 |
| 건너 | 2 | 항상 |
| 실드 트루퍼 | 3 | 항상 |
| 점퍼 | 4 | 깊이 3+ |
| 헤비 트루퍼 | 5 | 깊이 4+ |
| 해커 | 3 | 깊이 4+, 엔지니어 존재 시 확률↑ |
| 폭풍 생명체 | 3 | 폭풍 스테이지만 |
| 브루트 | 8 | 깊이 5+ |
| 스나이퍼 | 6 | 깊이 6+ |
| 드론 캐리어 | 7 | 깊이 7+ |
| 실드 제너레이터 | 5 | 깊이 6+ |

#### 13.4.3 웨이브 생성 알고리즘

```
1. 웨이브 예산 계산
2. 필수 적 타입 확인 (시나리오/이벤트 기반)
3. 예산 내에서 적 조합 생성:
   a. 50% 확률로 "테마" 선택 (러셔 집중, 원거리 집중 등)
   b. 기본 적 60~70% 채움
   c. 나머지 예산으로 고급 적 추가
4. 침투 방향 분배 (2~4 방향)
5. 침투 타이밍 설정 (0초, +5초, +10초...)
```

#### 13.4.4 웨이브 테마

| 테마 | 구성 | 특징 |
|------|------|------|
| 러시 | 러셔 80%+ | 물량 압도 |
| 원거리 | 건너 50%+ | 가디언 필요 |
| 방패벽 | 실드 트루퍼 40%+ | 측면 공격 필요 |
| 돌파 | 점퍼 30%+ 브루트 | 방어선 붕괴 위험 |
| 혼합 | 균등 분포 | 균형 대응 필요 |
| 해킹 | 해커 + 호위 | 터렛 보호 필수 |
| 저격 | 스나이퍼 + 엄호 | 바이오닉 필수 |

---

### 13.5 아이템/특성 풀 생성

#### 13.5.1 장비 등장 규칙

```
캠페인당 장비 드롭 수 = 6~8개

1. 첫 장비 (깊이 2~3): 기본 장비 풀에서 선택
   - Command Module, Shock Wave, Frag Grenade, Proximity Mine

2. 중반 장비 (깊이 5~10): 확장 풀 추가
   - Rally Horn, Stim Pack, Salvage Core, Shield Generator

3. 후반 장비 (깊이 10+): 희귀 풀 추가
   - Revive Kit, Hacking Device

4. 중복 방지: 이미 획득한 장비는 풀에서 제외
```

#### 13.5.2 팀장 특성 풀

```
캠페인 시작 시:
1. 15개 특성 중 10개 활성화 (랜덤)
2. 제외된 5개는 해당 캠페인에서 등장 안 함
3. 동일 특성 팀장 중복 등장 불가

팀장 영입 시:
1. 활성화된 풀에서 미사용 특성 선택
2. 클래스와의 시너지 가중치 적용 (50% 확률)
   예: 엔지니어 → Tech Savvy 확률↑
```

---

### 13.6 시드 시스템

#### 13.6.1 시드 구조

```
시드 형식: XXXX-YYYY-ZZZZ (12자리)

XXXX: 섹터 맵 시드
YYYY: 정거장 레이아웃 시드
ZZZZ: 적/아이템 시드
```

#### 13.6.2 시드 활용

| 모드 | 시드 사용 |
|------|----------|
| 일반 플레이 | 자동 생성 |
| 시드 입력 | 특정 맵 재현 |
| 일일 챌린지 | 전체 플레이어 동일 시드 |
| 경쟁 모드 | 시드 + 스코어 비교 |

#### 13.6.3 결정론적 생성

```
동일 시드 + 동일 난이도 = 항상 동일한 결과

보장 항목:
- 섹터 맵 구조
- 정거장 레이아웃
- 시설 배치
- 적 웨이브 구성
- 아이템/팀장 특성 풀

비결정적 항목 (플레이어 행동 의존):
- 실제 전투 결과
- 경로 선택
- 업그레이드 선택
```

---

### 13.7 생성 검증

#### 13.7.1 유효성 검사

| 검사 항목 | 조건 |
|-----------|------|
| 경로 연결 | 시작점 → 게이트 도달 가능 |
| 시설 접근 | 모든 시설 도달 가능 |
| 침투점 균형 | 2개 이상, 한쪽 집중 금지 |
| 팀장 기회 | 최소 2회 영입 기회 |
| 장비 기회 | 최소 4회 획득 기회 |
| 난이도 곡선 | 급격한 점프 없음 |

#### 13.7.2 재생성 조건

```
IF 유효성 검사 실패:
   시드 변형 후 재생성 (최대 3회)

IF 3회 실패:
   템플릿 기반 폴백 생성
```

---

### 13.8 심화: 섹터 맵 그래프 알고리즘

#### 13.8.1 Layered Graph Generation

섹터 맵은 **계층화된 방향 비순환 그래프(Layered DAG)**로 모델링한다.

```
데이터 구조:

Node {
    id: int
    layer: int                    // 깊이 (0 = 시작, N = 게이트)
    x_position: float             // 0.0 ~ 1.0 정규화된 X 위치
    event_type: EventType         // NORMAL, COMMANDER, ITEM, STORM, BOSS
    difficulty_score: float
    connections_in: List<Node>    // 이전 레이어 연결
    connections_out: List<Node>   // 다음 레이어 연결
}

Graph {
    layers: List<List<Node>>
    total_depth: int
    seed: int
}
```

#### 13.8.2 노드 배치 상세 알고리즘

```python
def generate_sector_map(seed, difficulty):
    rng = SeededRandom(seed)

    # 1. 레이어 수 결정
    depth = rng.range(DEPTH_MIN[difficulty], DEPTH_MAX[difficulty])

    # 2. 각 레이어 노드 생성
    for layer in range(depth):
        # 노드 수 결정 (정규 분포 + 클램핑)
        base_count = rng.normal(mean=2.5, stddev=0.7)
        node_count = clamp(round(base_count),
                          MIN_NODES[difficulty],
                          MAX_NODES[difficulty])

        # X 위치 분배 (겹침 방지)
        positions = distribute_positions(node_count, rng)

        for i in range(node_count):
            node = create_node(layer, positions[i])
            graph.add_node(node)

    # 3. 엣지 연결
    connect_layers(graph, rng)

    # 4. 이벤트 배치
    place_events(graph, rng, difficulty)

    # 5. 난이도 점수 계산
    calculate_difficulty_scores(graph)

    return graph
```

#### 13.8.3 위치 분배 알고리즘 (Anti-Clustering)

```python
def distribute_positions(count, rng):
    """노드가 너무 가깝지 않도록 분배"""

    if count == 1:
        return [0.5]

    # 균등 분배 기본값
    base_positions = [i / (count - 1) for i in range(count)]

    # 랜덤 오프셋 추가 (최대 ±15%)
    positions = []
    for base in base_positions:
        offset = rng.uniform(-0.15, 0.15)
        pos = clamp(base + offset, 0.05, 0.95)
        positions.append(pos)

    # 최소 간격 보장 (0.2)
    positions = enforce_minimum_spacing(positions, min_gap=0.2)

    return sorted(positions)
```

#### 13.8.4 연결 알고리즘 (Constrained Edge Generation)

```python
def connect_layers(graph, rng):
    """인접 레이어 간 연결 생성"""

    for layer_idx in range(len(graph.layers) - 1):
        current_layer = graph.layers[layer_idx]
        next_layer = graph.layers[layer_idx + 1]

        # Phase 1: 모든 노드가 최소 1개 연결 보장
        for node in current_layer:
            # 가장 가까운 다음 레이어 노드 연결
            nearest = find_nearest_node(node, next_layer)
            connect(node, nearest)

        for node in next_layer:
            if len(node.connections_in) == 0:
                # 고립 노드 → 가장 가까운 이전 노드 연결
                nearest = find_nearest_node(node, current_layer)
                connect(nearest, node)

        # Phase 2: 추가 연결 (분기/합류)
        for node in current_layer:
            if rng.chance(BRANCH_PROBABILITY):
                # 두 번째로 가까운 노드에 추가 연결
                candidates = get_unconnected_near_nodes(node, next_layer)
                if candidates:
                    second = candidates[0]
                    connect(node, second)

        # Phase 3: 크로스 연결 방지 (시각적 정리)
        remove_crossing_edges(current_layer, next_layer)
```

#### 13.8.5 크로스 연결 제거

```python
def remove_crossing_edges(layer_a, layer_b):
    """
    교차하는 엣지 중 하나 제거 (시각적 명확성)
    단, 고립 노드가 생기지 않도록 보장
    """
    edges = get_all_edges(layer_a, layer_b)

    for i, edge1 in enumerate(edges):
        for edge2 in edges[i+1:]:
            if edges_cross(edge1, edge2):
                # 제거 가능한 엣지 선택 (연결 수 많은 쪽)
                if can_remove(edge1) and degree(edge1.from) > 1:
                    remove(edge1)
                elif can_remove(edge2) and degree(edge2.from) > 1:
                    remove(edge2)
```

---

### 13.9 심화: 정거장 레이아웃 - BSP + WFC 하이브리드

#### 13.9.1 Binary Space Partitioning (BSP) 기반 방 생성

```python
class BSPNode:
    def __init__(self, x, y, width, height):
        self.bounds = Rect(x, y, width, height)
        self.left = None
        self.right = None
        self.room = None  # 리프 노드에만 존재

def generate_bsp_layout(width, height, seed, min_room_size=3):
    rng = SeededRandom(seed)
    root = BSPNode(0, 0, width, height)

    # 재귀적 분할
    split_node(root, rng, min_room_size)

    # 각 리프에 방 생성
    create_rooms(root, rng)

    # 복도 연결
    connect_rooms(root)

    return root

def split_node(node, rng, min_size):
    """노드를 수직/수평으로 분할"""

    # 분할 가능 여부 확인
    if node.bounds.width < min_size * 2 and node.bounds.height < min_size * 2:
        return  # 더 이상 분할 불가

    # 분할 방향 결정 (종횡비 기반 + 랜덤)
    if node.bounds.width > node.bounds.height * 1.25:
        split_vertical = True
    elif node.bounds.height > node.bounds.width * 1.25:
        split_vertical = False
    else:
        split_vertical = rng.chance(0.5)

    # 분할 위치 (40% ~ 60% 범위)
    if split_vertical:
        split_pos = rng.range(
            int(node.bounds.width * 0.4),
            int(node.bounds.width * 0.6)
        )
        node.left = BSPNode(node.bounds.x, node.bounds.y,
                           split_pos, node.bounds.height)
        node.right = BSPNode(node.bounds.x + split_pos, node.bounds.y,
                            node.bounds.width - split_pos, node.bounds.height)
    else:
        split_pos = rng.range(
            int(node.bounds.height * 0.4),
            int(node.bounds.height * 0.6)
        )
        node.left = BSPNode(node.bounds.x, node.bounds.y,
                           node.bounds.width, split_pos)
        node.right = BSPNode(node.bounds.x, node.bounds.y + split_pos,
                            node.bounds.width, node.bounds.height - split_pos)

    # 재귀 분할
    split_node(node.left, rng, min_size)
    split_node(node.right, rng, min_size)
```

#### 13.9.2 방 생성 및 시설 배치

```python
def create_rooms(node, rng):
    """리프 노드에 방 생성"""
    if node.left is None and node.right is None:
        # 리프 노드: 방 생성
        padding = 1
        room_width = rng.range(
            max(3, node.bounds.width - padding * 2 - 2),
            node.bounds.width - padding * 2
        )
        room_height = rng.range(
            max(3, node.bounds.height - padding * 2 - 2),
            node.bounds.height - padding * 2
        )

        room_x = node.bounds.x + rng.range(padding,
                  node.bounds.width - room_width - padding)
        room_y = node.bounds.y + rng.range(padding,
                  node.bounds.height - room_height - padding)

        node.room = Room(room_x, room_y, room_width, room_height)

        # 시설 배치 여부 결정
        if rng.chance(FACILITY_CHANCE):
            node.room.facility = select_facility(rng)
    else:
        if node.left:
            create_rooms(node.left, rng)
        if node.right:
            create_rooms(node.right, rng)
```

#### 13.9.3 Wave Function Collapse (WFC) 기반 타일 배치

```python
class TileType(Enum):
    VOID = 0      # 우주 공간
    FLOOR = 1     # 바닥
    WALL = 2      # 벽
    AIRLOCK = 3   # 에어락 (침투점)
    ELEVATED = 4  # 고지대
    FACILITY = 5  # 시설

# 인접 규칙 정의 (어떤 타일이 어떤 타일 옆에 올 수 있는지)
ADJACENCY_RULES = {
    TileType.VOID: {
        'north': [VOID, WALL, AIRLOCK],
        'south': [VOID, WALL, AIRLOCK],
        'east':  [VOID, WALL, AIRLOCK],
        'west':  [VOID, WALL, AIRLOCK]
    },
    TileType.FLOOR: {
        'north': [FLOOR, WALL, AIRLOCK, ELEVATED, FACILITY],
        'south': [FLOOR, WALL, AIRLOCK, ELEVATED, FACILITY],
        'east':  [FLOOR, WALL, AIRLOCK, ELEVATED, FACILITY],
        'west':  [FLOOR, WALL, AIRLOCK, ELEVATED, FACILITY]
    },
    TileType.WALL: {
        'north': [VOID, FLOOR, WALL, ELEVATED],
        'south': [VOID, FLOOR, WALL, ELEVATED],
        'east':  [VOID, FLOOR, WALL, ELEVATED],
        'west':  [VOID, FLOOR, WALL, ELEVATED]
    },
    TileType.AIRLOCK: {
        'north': [VOID, FLOOR],
        'south': [VOID, FLOOR],
        'east':  [VOID, FLOOR],
        'west':  [VOID, FLOOR]
    },
    TileType.ELEVATED: {
        'north': [FLOOR, WALL, ELEVATED],
        'south': [FLOOR, WALL, ELEVATED],
        'east':  [FLOOR, WALL, ELEVATED],
        'west':  [FLOOR, WALL, ELEVATED]
    },
    TileType.FACILITY: {
        'north': [FLOOR, WALL],
        'south': [FLOOR, WALL],
        'east':  [FLOOR, WALL],
        'west':  [FLOOR, WALL]
    }
}

def wfc_collapse(grid, rng):
    """WFC 알고리즘으로 그리드 채우기"""

    # 초기화: 모든 셀에 모든 가능성
    for cell in grid.cells:
        cell.possibilities = set(TileType)

    while not all_collapsed(grid):
        # 1. 가장 낮은 엔트로피 셀 선택
        cell = get_lowest_entropy_cell(grid)

        if len(cell.possibilities) == 0:
            # 모순 발생 → 백트래킹 또는 재시작
            return None

        # 2. 가능성 중 하나 선택 (가중치 적용)
        chosen = weighted_choice(cell.possibilities, rng)
        cell.collapse(chosen)

        # 3. 제약 전파 (인접 셀 가능성 업데이트)
        propagate(grid, cell)

    return grid

def propagate(grid, collapsed_cell):
    """제약 전파: 붕괴된 셀의 영향을 주변에 전파"""
    stack = [collapsed_cell]

    while stack:
        current = stack.pop()
        current_type = current.collapsed_value

        for direction, neighbor in current.neighbors.items():
            if neighbor is None or neighbor.is_collapsed:
                continue

            # 인접 규칙에 따라 가능성 필터링
            allowed = set(ADJACENCY_RULES[current_type][direction])
            old_count = len(neighbor.possibilities)
            neighbor.possibilities &= allowed

            if len(neighbor.possibilities) < old_count:
                stack.append(neighbor)
```

#### 13.9.4 BSP + WFC 통합 파이프라인

```
1. BSP로 기본 방 구조 생성
      ↓
2. 방 영역을 FLOOR/FACILITY로 마킹
      ↓
3. 외곽을 VOID로 마킹
      ↓
4. WFC로 나머지 영역 (벽, 에어락, 고지대) 채우기
      ↓
5. 연결성 검증 (모든 시설 도달 가능?)
      ↓
6. 에어락(침투점) 위치 최종 결정
      ↓
7. 고지대/저지대 높이 맵 생성
```

---

### 13.10 심화: 동적 난이도 시스템 (AI Director)

#### 13.10.1 긴장도 모델 (Tension Model)

```python
class TensionManager:
    """Left 4 Dead 스타일 AI Director 적용"""

    def __init__(self):
        self.tension = 0.0          # 현재 긴장도 (0.0 ~ 1.0)
        self.peak_tension = 0.0     # 이번 웨이브 최대 긴장도
        self.relaxation_timer = 0   # 휴식 시간

        # 이상적인 긴장도 곡선 파라미터
        self.target_peak = 0.8      # 목표 최대 긴장도
        self.target_valley = 0.2    # 목표 최소 긴장도
        self.peak_duration = 30     # 최대 긴장 유지 시간 (초)
        self.valley_duration = 15   # 휴식 시간 (초)

    def update(self, game_state, delta_time):
        """매 프레임 긴장도 업데이트"""

        # 긴장도 계산 요소
        factors = {
            'active_enemies': len(game_state.enemies) / MAX_ENEMIES,
            'crew_health': 1.0 - game_state.avg_crew_health,
            'facility_damage': game_state.facility_damage_ratio,
            'recent_deaths': game_state.recent_crew_deaths * 0.2,
            'boss_present': 0.3 if game_state.boss_active else 0.0
        }

        # 가중 평균
        weights = [0.3, 0.25, 0.2, 0.15, 0.1]
        self.tension = sum(f * w for f, w in zip(factors.values(), weights))
        self.tension = clamp(self.tension, 0.0, 1.0)

        # 피크 추적
        self.peak_tension = max(self.peak_tension, self.tension)

    def should_spawn_wave(self):
        """다음 웨이브 스폰 여부 결정"""

        # 휴식 기간 중이면 스폰 안 함
        if self.relaxation_timer > 0:
            return False

        # 긴장도가 낮으면 스폰
        if self.tension < self.target_valley:
            return True

        # 긴장도가 너무 오래 높으면 잠시 휴식
        if self.tension > self.target_peak and self.peak_duration_exceeded():
            self.relaxation_timer = self.valley_duration
            return False

        return False

    def adjust_wave_intensity(self, base_budget):
        """현재 긴장도에 따라 웨이브 강도 조절"""

        # 긴장도 낮음 → 강한 웨이브
        # 긴장도 높음 → 약한 웨이브
        intensity_multiplier = 1.5 - self.tension  # 0.5 ~ 1.5

        return int(base_budget * intensity_multiplier)
```

#### 13.10.2 적응형 난이도 조절 (Adaptive Difficulty)

```python
class AdaptiveDifficulty:
    """플레이어 실력에 따른 난이도 조절"""

    def __init__(self):
        self.player_skill = 0.5     # 추정 플레이어 실력 (0.0 ~ 1.0)
        self.skill_history = []     # 최근 N개 스테이지 성과
        self.hidden_modifier = 1.0  # 숨겨진 난이도 배율

    def record_stage_result(self, result):
        """스테이지 결과 기록"""

        # 성과 점수 계산
        score = 0.0
        score += result.facilities_saved / result.total_facilities * 0.4
        score += result.crew_survived / result.total_crew * 0.3
        score += (1.0 - result.time_ratio) * 0.2  # 빠른 클리어 보너스
        score += 0.1 if result.no_deaths else 0.0

        self.skill_history.append(score)

        # 최근 5개 스테이지만 유지
        if len(self.skill_history) > 5:
            self.skill_history.pop(0)

        # 플레이어 실력 추정 업데이트
        self.update_skill_estimate()

    def update_skill_estimate(self):
        """플레이어 실력 추정치 업데이트"""

        if not self.skill_history:
            return

        # 최근 성과의 가중 평균 (최신일수록 가중치 높음)
        weights = [0.1, 0.15, 0.2, 0.25, 0.3][-len(self.skill_history):]
        avg_score = sum(s * w for s, w in zip(self.skill_history, weights))
        avg_score /= sum(weights)

        # 부드러운 전환
        self.player_skill = lerp(self.player_skill, avg_score, 0.3)

        # 숨겨진 난이도 배율 계산
        # 실력 높음 → 난이도 증가, 실력 낮음 → 난이도 감소
        if self.player_skill > 0.7:
            self.hidden_modifier = 1.0 + (self.player_skill - 0.7) * 0.5
        elif self.player_skill < 0.3:
            self.hidden_modifier = 1.0 - (0.3 - self.player_skill) * 0.3
        else:
            self.hidden_modifier = 1.0

    def get_adjusted_budget(self, base_budget):
        """조정된 웨이브 예산 반환"""
        return int(base_budget * self.hidden_modifier)
```

#### 13.10.3 긴장-이완 곡선 시각화

```
긴장도
  1.0 ─┐
      │    ╱╲      ╱╲      ╱╲
  0.8 ─┤   ╱  ╲    ╱  ╲    ╱  ╲     ← 목표 피크
      │  ╱    ╲  ╱    ╲  ╱    ╲
  0.5 ─┤ ╱      ╲╱      ╲╱      ╲
      │╱
  0.2 ─┤  ↑휴식   ↑휴식   ↑휴식     ← 목표 밸리
      │
  0.0 ─┴────────────────────────── 시간
       웨이브1  웨이브2  웨이브3
```

---

### 13.11 심화: 결정론적 난수 생성 (Seeded RNG)

#### 13.11.1 Xorshift128+ 구현

```python
class SeededRandom:
    """
    Xorshift128+ 알고리즘
    - 빠르고 충분한 품질의 PRNG
    - 동일 시드 → 동일 시퀀스 보장
    """

    def __init__(self, seed):
        # 시드를 두 개의 64비트 상태로 확장
        self.state = [
            self._splitmix64(seed),
            self._splitmix64(seed + 0x9E3779B97F4A7C15)
        ]

    def _splitmix64(self, x):
        """시드 초기화용 해시 함수"""
        x = (x ^ (x >> 30)) * 0xBF58476D1CE4E5B9
        x = (x ^ (x >> 27)) * 0x94D049BB133111EB
        x = (x ^ (x >> 31))
        return x & 0xFFFFFFFFFFFFFFFF

    def next(self):
        """다음 난수 생성 (0 ~ 2^64-1)"""
        s0, s1 = self.state
        result = (s0 + s1) & 0xFFFFFFFFFFFFFFFF

        s1 ^= s0
        self.state[0] = ((s0 << 24) | (s0 >> 40)) ^ s1 ^ (s1 << 16)
        self.state[1] = (s1 << 37) | (s1 >> 27)

        return result

    def random(self):
        """0.0 ~ 1.0 실수"""
        return self.next() / 0xFFFFFFFFFFFFFFFF

    def range(self, min_val, max_val):
        """min_val ~ max_val 정수"""
        return min_val + (self.next() % (max_val - min_val + 1))

    def chance(self, probability):
        """probability 확률로 True"""
        return self.random() < probability

    def choice(self, items):
        """리스트에서 하나 선택"""
        return items[self.range(0, len(items) - 1)]

    def weighted_choice(self, items, weights):
        """가중치 기반 선택"""
        total = sum(weights)
        r = self.random() * total
        cumulative = 0
        for item, weight in zip(items, weights):
            cumulative += weight
            if r <= cumulative:
                return item
        return items[-1]

    def shuffle(self, items):
        """Fisher-Yates 셔플"""
        result = list(items)
        for i in range(len(result) - 1, 0, -1):
            j = self.range(0, i)
            result[i], result[j] = result[j], result[i]
        return result

    def normal(self, mean=0, stddev=1):
        """정규 분포 (Box-Muller 변환)"""
        u1 = self.random()
        u2 = self.random()
        z0 = math.sqrt(-2 * math.log(u1)) * math.cos(2 * math.pi * u2)
        return mean + z0 * stddev
```

#### 13.11.2 다중 스트림 RNG

```python
class MultiStreamRNG:
    """
    목적별 분리된 RNG 스트림
    - 한 시스템의 변경이 다른 시스템에 영향 주지 않음
    """

    def __init__(self, master_seed):
        self.streams = {
            'sector_map': SeededRandom(master_seed ^ 0xAAAAAAAA),
            'station_layout': SeededRandom(master_seed ^ 0xBBBBBBBB),
            'enemy_waves': SeededRandom(master_seed ^ 0xCCCCCCCC),
            'items': SeededRandom(master_seed ^ 0xDDDDDDDD),
            'traits': SeededRandom(master_seed ^ 0xEEEEEEEE),
            'visual': SeededRandom(master_seed ^ 0xFFFFFFFF)  # 시각 효과용
        }

    def get(self, stream_name):
        return self.streams[stream_name]
```

#### 13.11.3 시드 파싱 및 생성

```python
def parse_seed(seed_string):
    """
    "ABCD-1234-WXYZ" 형식의 시드 문자열 파싱
    """
    parts = seed_string.upper().split('-')
    if len(parts) != 3:
        raise ValueError("Invalid seed format")

    # 각 파트를 36진수로 해석
    sector_seed = int(parts[0], 36)
    layout_seed = int(parts[1], 36)
    content_seed = int(parts[2], 36)

    # 마스터 시드 생성
    master_seed = (sector_seed << 32) ^ (layout_seed << 16) ^ content_seed

    return master_seed

def generate_seed_string(master_seed=None):
    """
    랜덤 시드 문자열 생성
    """
    import time

    if master_seed is None:
        master_seed = int(time.time() * 1000) ^ id(object())

    # 36진수 문자열로 변환
    chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"

    def to_base36(n, length=4):
        result = ""
        for _ in range(length):
            result = chars[n % 36] + result
            n //= 36
        return result

    part1 = to_base36((master_seed >> 32) & 0xFFFF)
    part2 = to_base36((master_seed >> 16) & 0xFFFF)
    part3 = to_base36(master_seed & 0xFFFF)

    return f"{part1}-{part2}-{part3}"
```

---

### 13.12 심화: 노이즈 기반 지형 생성

#### 13.12.1 Perlin Noise를 활용한 고도 맵

```python
class PerlinNoise:
    """2D Perlin Noise 생성기"""

    def __init__(self, seed):
        self.rng = SeededRandom(seed)
        # 256개의 순열 테이블 생성
        self.perm = list(range(256))
        self.perm = self.rng.shuffle(self.perm)
        self.perm = self.perm + self.perm  # 2배로 확장

    def _fade(self, t):
        """부드러운 보간을 위한 감쇠 함수"""
        return t * t * t * (t * (t * 6 - 15) + 10)

    def _lerp(self, a, b, t):
        return a + t * (b - a)

    def _grad(self, hash_val, x, y):
        """그래디언트 벡터 계산"""
        h = hash_val & 3
        if h == 0: return x + y
        if h == 1: return -x + y
        if h == 2: return x - y
        return -x - y

    def noise(self, x, y):
        """주어진 좌표의 노이즈 값 (-1 ~ 1)"""
        # 정수 좌표
        xi = int(x) & 255
        yi = int(y) & 255

        # 소수 좌표
        xf = x - int(x)
        yf = y - int(y)

        # 감쇠 적용
        u = self._fade(xf)
        v = self._fade(yf)

        # 해시 값
        aa = self.perm[self.perm[xi] + yi]
        ab = self.perm[self.perm[xi] + yi + 1]
        ba = self.perm[self.perm[xi + 1] + yi]
        bb = self.perm[self.perm[xi + 1] + yi + 1]

        # 보간
        x1 = self._lerp(self._grad(aa, xf, yf),
                        self._grad(ba, xf - 1, yf), u)
        x2 = self._lerp(self._grad(ab, xf, yf - 1),
                        self._grad(bb, xf - 1, yf - 1), u)

        return self._lerp(x1, x2, v)

    def octave_noise(self, x, y, octaves=4, persistence=0.5):
        """다중 옥타브 노이즈 (더 자연스러운 결과)"""
        total = 0
        frequency = 1
        amplitude = 1
        max_value = 0

        for _ in range(octaves):
            total += self.noise(x * frequency, y * frequency) * amplitude
            max_value += amplitude
            amplitude *= persistence
            frequency *= 2

        return total / max_value

def generate_height_map(width, height, seed):
    """정거장 고도 맵 생성"""
    noise = PerlinNoise(seed)
    height_map = []

    scale = 0.1  # 노이즈 스케일

    for y in range(height):
        row = []
        for x in range(width):
            # 노이즈 값 (-1 ~ 1) → 고도 (0, 1, 2)
            n = noise.octave_noise(x * scale, y * scale)

            if n < -0.3:
                elevation = 0  # 저지대
            elif n > 0.3:
                elevation = 2  # 고지대
            else:
                elevation = 1  # 평지

            row.append(elevation)
        height_map.append(row)

    return height_map
```

---

### 13.13 검증 및 디버깅 도구

#### 13.13.1 맵 시각화 (디버그용)

```python
def visualize_sector_map(graph):
    """섹터 맵 ASCII 시각화"""
    output = []

    for layer_idx, layer in enumerate(graph.layers):
        # 노드 표시
        line = "  " * 10  # 기본 패딩
        for node in layer:
            pos = int(node.x_position * 20)
            symbol = get_event_symbol(node.event_type)
            line = line[:pos] + symbol + line[pos+1:]
        output.append(f"L{layer_idx:02d} {line}")

        # 연결선 표시 (다음 레이어로)
        if layer_idx < len(graph.layers) - 1:
            connection_line = draw_connections(layer, graph.layers[layer_idx + 1])
            output.append(f"    {connection_line}")

    return "\n".join(output)

def get_event_symbol(event_type):
    symbols = {
        EventType.NORMAL: '○',
        EventType.COMMANDER: '🚩',
        EventType.ITEM: '❓',
        EventType.STORM: '⚡',
        EventType.BOSS: '💀',
        EventType.GATE: '🚪'
    }
    return symbols.get(event_type, '?')
```

#### 13.13.2 생성 통계 수집

```python
class GenerationStats:
    """맵 생성 통계 수집 (밸런싱 검증용)"""

    def __init__(self):
        self.samples = []

    def record(self, graph, station_layouts):
        stats = {
            'total_nodes': sum(len(layer) for layer in graph.layers),
            'total_depth': len(graph.layers),
            'commander_count': count_events(graph, EventType.COMMANDER),
            'item_count': count_events(graph, EventType.ITEM),
            'storm_count': count_events(graph, EventType.STORM),
            'boss_count': count_events(graph, EventType.BOSS),
            'avg_branching': calculate_avg_branching(graph),
            'avg_station_size': np.mean([s.tile_count for s in station_layouts]),
            'avg_facilities': np.mean([s.facility_count for s in station_layouts]),
            'avg_entry_points': np.mean([s.entry_count for s in station_layouts])
        }
        self.samples.append(stats)

    def report(self):
        """통계 리포트 출력"""
        if not self.samples:
            return "No samples"

        report = "=== Generation Statistics ===\n"

        for key in self.samples[0].keys():
            values = [s[key] for s in self.samples]
            report += f"{key}:\n"
            report += f"  Min: {min(values):.2f}\n"
            report += f"  Max: {max(values):.2f}\n"
            report += f"  Avg: {np.mean(values):.2f}\n"
            report += f"  Std: {np.std(values):.2f}\n"

        return report
```

#### 13.13.3 자동화된 플레이테스트

```python
class AutoPlaytest:
    """자동화된 맵 플레이 가능성 테스트"""

    def test_map(self, graph, stations, num_simulations=100):
        results = []

        for _ in range(num_simulations):
            result = self.simulate_playthrough(graph, stations)
            results.append(result)

        return {
            'completion_rate': sum(r['completed'] for r in results) / len(results),
            'avg_depth_reached': np.mean([r['depth_reached'] for r in results]),
            'avg_commanders_recruited': np.mean([r['commanders'] for r in results]),
            'choke_points': self.identify_choke_points(results)
        }

    def simulate_playthrough(self, graph, stations):
        """간단한 AI로 플레이스루 시뮬레이션"""
        state = SimulationState()

        while not state.game_over and state.current_depth < len(graph.layers):
            # 현재 선택 가능한 노드
            options = graph.get_available_nodes(state.current_depth)

            # 간단한 휴리스틱으로 선택
            chosen = self.select_node(options, state)

            # 전투 시뮬레이션
            battle_result = self.simulate_battle(
                stations[chosen.id],
                state.crew_power
            )

            state.apply_result(battle_result)
            state.current_depth += 1

        return state.to_result()
```

---

## 14. 밸런싱 수치

### 14.1 업그레이드 비용 요약

| 대상 | Lv1 | Lv2 | Lv3 | 합계 |
|------|-----|-----|-----|------|
| 클래스 등급 | 6 | 12 | 20 | 38 |
| 스킬 | 7 | 10 | 14 | 31 |
| Frag/Mine | - | 8 | 14 | 22 |
| Salvage Core | - | 5 | 9 | 14 |
| Command Module | - | 16 | - | 16 |

### 14.2 분대 크기

| 클래스 | 기본 | Command Lv1 | Command Lv2 |
|--------|------|-------------|-------------|
| 가디언/센티넬/레인저 | 8 | 11 | 14 |
| 엔지니어 | 6 | 8 | 10 |
| 바이오닉 | 5 | 7 | 9 |

### 14.3 회복 시간

```
회복 시간 = 2 × 분대크기 (초)

기본 (8명): 16초
Command Lv1 (11명): 22초
Command Lv2 (14명): 28초
엔지니어 (6명): 12초
바이오닉 (5명): 10초
```

**수정 요소**
- Quick Recovery 특성: -33%
- 의료 모듈: -50%

### 14.4 적 체력 (히트 수)

| 적 | Normal | Hard | Very Hard |
|----|--------|------|-----------|
| 러셔 | 1 | 1 | 2 |
| 건너 | 1 | 1 | 2 |
| 실드 트루퍼 | 2 | 3 | 4 |
| 점퍼 | 2 | 3 | 4 |
| 헤비 트루퍼 | 3 | 4 | 5 |
| 해커 | 1 | 1 | 2 |
| 브루트 | 6 | 8 | 10 |
| 스나이퍼 | 1 | 2 | 2 |
| 드론 캐리어 | 3 | 4 | 5 |
| 해적 대장 | 15 | 20 | 25 |

### 14.5 스킬 쿨다운

| 스킬 | 기본 | Energetic |
|------|------|-----------|
| Shield Bash | 20초 | 13초 |
| Lance Charge | 25초 | 17초 |
| Volley Fire | 15초 | 10초 |
| Deploy Turret | 30초 | 20초 |
| Blink | 15초 | 10초 |

### 14.6 장비 쿨다운

| 장비 | 쿨다운 |
|------|--------|
| Shock Wave | 40초 |
| Shield Generator | 60초 |

### 14.7 특성 수치

| 특성 | 수치 |
|------|------|
| Sharp Edge | 데미지 +20%, 넉백 -30% |
| Heavy Impact | 넉백 +50%, 스턴 +50% |
| Reinforced Armor | 받는 데미지 -25% |
| Energetic | 쿨다운 -33% |
| Swift Movement | 이동속도 +33% |
| Quick Recovery | 회복 시간 -33% |
| Tech Savvy | 터렛 성능 +50% |
| Popular | 분대 +1 |
| Skillful | 스킬 비용 -50% |
| Collector | 장비 비용 -50% |
| Heavy Load | 소모품 +1 |

---

## 부록: Bad North 대응표

| Bad North | The Fading Raven |
|-----------|------------------|
| 섬 | 정거장 |
| 집 | 시설 모듈 |
| 골드 | 크레딧 |
| 지휘관 | 팀장 |
| 분대 | 크루 |
| 바이킹 | 해적단/폭풍 생명체 |
| 보트 상륙 | 침투정/포탈 |
| 물 (즉사) | 우주 공간 (즉사) |
| 바이킹 전선 | 폭풍 전선 |
| 보병 | 가디언 |
| 창병 | 센티넬 |
| 궁수 | 레인저 |
| - | 엔지니어 (신규) |
| - | 바이오닉 (신규) |
| - | Raven 드론 (신규) |

---

*문서 작성일: 2026-02-02*
*최종 수정: 2026-02-02 (절차적 생성 시스템 심화 설계 추가)*
*The Fading Raven Game Design Document v1.2*
